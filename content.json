{"pages":[{"title":"","text":"&gt;&gt;个人简介 尚未佩妥剑，转眼便江湖。愿历尽千帆，归来仍少年。 初心不变，恒至终点。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程。💪💪💪💪💪💪冲鸭！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：码仔一枚计算机科学与技术专业从事web前端开发坚信代码使得世界更精彩 &gt;&gt;博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 分享自己的技术总结与心得。 如有不足之处，欢迎各路高手赐教。 &gt;&gt;计划2022计划 -&gt;更新于2022.11.03 完成笔记 –&gt; blog 的迁移 自今日起，刷25道算法题 –&gt;（0%） &gt;&gt;时间轴记录","link":"/about/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：.jpg 网站名称： 网站地址： 网站简介： 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"碎碎念","text":"碎碎念 「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: 'f806584ed1535389dc57', clientSecret: '035600e77f12d00406116b25d3c5a1116c41db00', id: 'gitalk-self-talking', repo: 'blog', owner: 'vrchild', admin: ['vrchild'], createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"},{"title":"个人音乐收藏馆","text":"温馨提示：选择喜欢的音乐单机播放，由于版权原因部分不能播放。如果喜欢歌单 收藏 一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"}],"posts":[{"title":"js的执行机制","text":"","link":"/2022/11/02/categories/executionMechanism/"},{"title":"promise","text":"promiseprimise是解决异步编程的一种方案，也是ES6统一了用法，promise是一个构造函数，用来生成promise实例 优点 可以将异步的操纵以同步的形式展现出来，避免了层层嵌套的回调函数，使代码更加优雅 缺点 无法取消 Promise，一旦新建它就会立即执行，无法中途取消 如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部 当处于 Pending状态时，无法得知目前进展到哪一个阶段(刚刚开始还是即将完成) 参数 new Promise((==resolve==, ==reject==) =&gt; {}promise自己身上的方法作为参数: resolve: 将promise的状态改为fulfilled（完成） reject: 将promise的状态改为rejected（失败） promise.then(res =&gt; {}, e =&gt; {}) onfulfilled: Promise状态为fulfilled，调用then的onfulfilled方法 onrejected: Promise状态为rejected，调用then的onrejected方法 状态 pending: 初始状态，既不是成功，也不是失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 一个 Promise 只有这 3 种状态，且状态的转换过程有且仅有 2 种 pending到fulfilled pending到rejected then / catch1234567891011121314151617181920212223// Promise新建后就会立即执行（执行new Promise）let promise = new Promise((resolve, reject) =&gt; { // 同步宏任务 console.log('123'); resolve('resolve') // reject('reject') promise.then( onfulfilled =&gt; { console.log('onfulfilled', onfulfilled); }, onrejected =&gt; { console.log('onrejected', onrejected); } ) // 原型上的then,catch(常规写法) promise.then((val) =&gt; { // 微任务 console.log('then', val); }) promise.catch((val) =&gt; { // 微任务 console.log('catch', val); })}) finallyfinally()方法只有当状态变化的时候才会执行(即调用resolve()或reject())，可以用来做一些程序的收尾工作，比如操作文件的时候关闭文件流。 12345678910111213141516let promise = new Promise((resolve, reject) =&gt; { // resolve('resolve') reject('reject')})promise.then( res =&gt; { console.log('res', res); }, e =&gt; { console.log('e', e); })promise.finally(() =&gt; { console.log('finally');})// e reject , finally allPromise 的 all 可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回==最先==被reject失败状态的值Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。） 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。123456789101112131415161718192021222324252627282930313233343536let promise1 = new Promise((resolve, reject) =&gt; { resolve('resolve1') // reject('reject1') }) ⭐// p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。 let promise2 = new Promise((resolve, reject) =&gt; { // resolve('resolve2') // reject('reject2') setTimeout(() =&gt; { reject('reject2') }, 1000) }).catch(e =&gt; { console.log('promise2, catch', e); }) let promise3 = new Promise((resolve, reject) =&gt; { resolve('resolve3') // reject('reject3') }) let promise = Promise.all([promise1, promise2, promise3]) ⭐//这里加不会影响 // promise2.catch(e =&gt; { // console.log('promise2, catch', e); // }) promise.then( res =&gt; { // 全是fulfilled状态--- res (3) ['resolve1', 'resolve2', 'resolve3'] console.log('res', res); }, e =&gt; { // 一个rejected状态--- e reject2 console.log('e', e); } ) // promise.finally(() =&gt; { // console.log('finally'); // }) race()Promise.race([p1, p2,p3])里面哪个结果==获得的快==，就返回那个结果，不管结果本身是成功状态还是失败状态。（使用场景基本没有）","link":"/2022/11/02/categories/peomise/"}],"tags":[{"name":"js","slug":"js","link":"/tags/js/"},{"name":"执行机制","slug":"执行机制","link":"/tags/%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"},{"name":"promise","slug":"promise","link":"/tags/promise/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"js的执行机制","slug":"JavaScript/js的执行机制","link":"/categories/JavaScript/js%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"},{"name":"promise","slug":"JavaScript/promise","link":"/categories/JavaScript/promise/"}]}